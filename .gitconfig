[user]
    name = Stephen Kent
    email = smkent@smkent.net
[core]
    editor = vim
    pager = less -F -R -X -x1,5
    excludesfile = ~/.gitignore.global
[color]
    ui = true
[push]
    default = upstream
[branch]
    autosetuprebase = always
[color "branch"]
    remote = 9      # Lighter red
    upstream = blue bold
[color "decorate"]
    HEAD = red bold
    remoteBranch = blue bold
    tag = yellow bold
[color "diff"]
    frag = blue bold
    func = magenta bold
[color "grep"]
    context = white dim
    filename = magenta
    function = yellow
    linenumber = green
    match = red bold
    separator = blue
[color "status"]
    added = green
    branch = white bold ul
    changed = 9     # Bright red
    unmerged = 11   # Bright yellow
    untracked = 32  # Brighter blue
[merge]
    conflictstyle = diff3
[log]
    date = local
[advice]
    statusHints = false
[diff]
    mnemonicprefix = true
    renames = copies
[alias]
    au = add -u
    b = branch
    br = branch -vv
    ca = commit --amend
    cf = commit --amend --no-edit  # "commit fixup"
    ci = commit
    co = checkout
    d = diff
    ds = diff --staged
    dw = diff --word-diff=color  # "diff words"
    ec = config --global -e  # "edit config"
    # "find alias"; based on "finda" from: http://brettterpstra.com/2014/08/04/
    # shell-tricks-one-git-alias-to-rule-them-all/
    fa = "!f() { git config --global --get-regexp alias | \
          grep -i \"$1\" | awk -v nr=2 \
          '{sub(/^alias\\./,\"\")};{printf(\"\\033[1;34m%10s\\033[0;0m\", $1)};\
           {sep=FS};{for (x=nr; x<=NF; x++) {printf \"%s%s\", sep, $x; };\
           print \"\\033[0;39m\"}'; }; f"
    lo = log --oneline --decorate  # "log oneline"
    l1 = log -n 1  # "log 1"
    # "log date", using committer date instead of author date
    ld = log --oneline --date=short \
             --pretty=format:'%C(yellow)%h %C(blue)%cd%C(cyan)%C(reset) %s %C(green)[%aN]'
    lf = log --oneline --decorate --numstat  # "log files"
    rh = reset HEAD
    # "rebase interactive"; $1 is either a ref or a number of commits to rebase
    ri = "!f() { r=\"${1}\"; if [ \"${1}\" -eq \"${1}\" ]; then r=\"@~${1}\"; \
                 fi >/dev/null 2>&1; git rebase -i \"${r}\"; }; f"
    sb = show-branch
    st = status
    s = status -s
    # "upstream branch"; compare local and remote tracking branch histories
    ub = "!f() { h=${1:-$(git symbolic-ref -q HEAD)} && git show-branch \
                 $(git for-each-ref --format='%(upstream:short)' \
                   \"refs/heads/${h#refs/heads/}\") \"${h}\"; }; f"
